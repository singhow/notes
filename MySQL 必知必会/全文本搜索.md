##全文本搜索
**LIKE 关键字**和**正则表达式**都可用于**搜索文本**，但它们存在几个限制：
- **性能**
> 通配符和正则表达式通常要求 MySQL 尝试匹配表中所有行，由于被搜索行数的不断增加，这些搜索可能非常耗时。
- **明确的控制**
> 使用通配符和正则表达式很难明确地控制匹配什么和不匹配什么。
> 
> 例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。
- **智能化的结果**
> 通配符和正则表达式都不能提供一种智能化的选择结果的方法。
> 
> 例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行。

所有这些限制以及更多的限制都可以用**全文本搜索**来解决。使用全文本搜索时，MySQL 不需要分别查看每个行，不需要分别分析和处理每个词。
> MySQL 创建指定列中**各词的一个索引**，搜索可以针对这些词进行。
> > MySQL 可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，它们匹配的频率，等等。

为了进行全文本搜索，必须**索引被搜索的列**，而且要随着数据的改变不断地**重新索引**。
> 在对表列进行适当设计后， MySQL 会自动进行所有的索引和重新索引。
> 
> 在索引之后，SELECT 可与 **Match() 和 Against()** 函数一起使用以实际执行搜索。

一般在创建表时启用全文本搜索。 CREATE TABLE 语句**接受 FULLTEXT 子句**，它给出被索引列的一个**逗号分隔的列表**。
```
CREATE TABLE productnotes
(
  note_id    int           NOT NULL AUTO_INCREMENT,
  prod_id    char(10)      NOT NULL,
  note_date datetime       NOT NULL,
  note_text  text          NULL ,
  PRIMARY KEY(note_id),
  FULLTEXT(note_text)
) ENGINE=MyISAM;
```
> MySQL 根据子句 FULLTEXT(note_text) 的指示**对 note_text 进行索引**, FULLTEXT() 也可**索引多个列**。
> 
> 在定义之后，MySQL **自动维护该索引**。在增加、更新或删除行时，索引随之**自动更新**。

由于**更新索引**需要**耗费时间**，因此不应该在导入数据到一个新表时启用 FULLTEXT 索引。
> 应该首先导入所有数据，然后再修改表，定义 FULLTEXT。 这样有助于更快地导入数据。

在索引之后，使用 Match() 和 Against() 函数执行全文本搜索。
- **Match()**
> 指定被搜索的列。
> 
> 传递给 Match() 的值必须与 FULLTEXT() 定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。
- **Against()**
> 指定要使用的搜索表达式。
> 
> 除非使用 BINARY 关键字，否则全文本搜索**不区分大小写**。

###全文本搜索
```
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('rabbit');
```
> SELECT 语句检索 note_text 列，WHERE 子句中一个全文本搜索被执行。
> 
> Match(note_text) 指示 MySQL 针对指定的列进行搜索，Against('rabbit') 指定 rabbit 作为搜索文本。

可使用 LIKE 子句完成前述的全文本搜索：
```
SELECT note_text
FROM productnotes
WHERE note_text LIKE '%rabbit%';
```
> 使用 LIKE 以不是特别有用的顺序返回数据。
> 
> 使用全文本搜索则**返回以文本匹配的良好程度排序**的数据。
> > 全文本搜索的一个重要部分就是**对结果排序**。具有**较高等级的行**先返回。

```
SELECT note_text, Match(note_text) Against('rabbit') AS rank
FROM productnotes;
```
> 返回所有行，Match() 和 Against() 用来**建立一个计算列**，此列包含全文本搜索计算出的等级值。
> 
> 等级由 MySQL 根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。
> > 不包含 rabbit 的行等级为 0。
> 
> > 包含 rabbit 的两个行每行都有一个等级值，文本中匹配词靠前的行的等级值比匹配词靠后的行的等级值高。
> 
> > 若指定多个搜索项，则包含多数匹配词的那些行的等级值高于包含较少词（或仅有一个匹配）的那些行。

###查询扩展
**查询扩展**用来设法**放宽**所返回的全文本搜索**结果的范围**。在使用查询扩展时，MySQL 对数据和索引进行**两遍扫描**来完成搜索：
- 首先，进行一个基本的全文本搜索，找出与搜索条件**匹配的所有行**。
- 其次，MySQL 检查这些匹配行并选择所有**有用的词**。
- 然后，MySQL 再次进行全文本搜索，这次的搜索条件还包括所有有用的词。

查询扩展通过在 Against() 中使用 **WITH QUERY EXPANSION 关键字**来指定。
```
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION);
```
> 返回 7 行数据。第一行包括 anvils。
> 
> 第二行于 anvils 无关，但因为包含第一行中的两个词（customer 和 recommend），所以也被检索出来。
> 
> 第 3 行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远。
> 
> 表中的**行越多**（这些行中的文本就越多），使用查询扩展**返回的结果越好**。

###布尔搜索
MySQL 支持以**布尔方式**（booleanmode）执行全文本搜索。以布尔方式，可以提供关于如下内容的细节：
- **要匹配的词**
- **要排斥的词**
> 若某行包含这个词，则不返回该行，即使它包含其他指定的词。
- **排列提示**
> 指定某些词比其他词更重要，更重要的词等级更高。
- **表达式分组**
- 另外一些内容

即使**没有**定义 **FULLTEXT 索引**也可以使用**布尔方式**，但这会非常**缓慢**。

布尔方式通过在 Against() 中使用 **IN BOOLEAN MODE 关键字**来指定。
```
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('heavy' IN BOOLEAN MODE);
```
> 检索包含 heavy 的所有行（有两行）。
> 
> 虽然使用了关键字 IN BOOLEAN MODE，但实际上没有指定布尔操作符，因此结果与没有指定布尔方式的结果相同。

```
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);
```
> 匹配包含 heavy 但**不包含任意以 rope 开始的行**。
> 
> -rope\* 明确地指示 MySQL 排除包含 rope\*（任何以 rope 开始的词，包括 ropes）的行。

**全文本布尔操作符**

| 布尔操作符 | 说明 |
| --- | --- |
| + | 包含，词必须存在 |
| - | 排除，词必须不出现 |
| > | 包含，而且增加等级值 |
| < | 包含，且减少等级值 |
| () | 把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等） |
| ~ | 取消一个词的排序值 |
| * | 词尾的通配符 |
| "" | 定义一个短语（与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） |

关于全文本搜索的一些重要的说明：
- 在索引全文本数据时，**短词**被忽略且从索引中**排除**。
> 短词定义为那些具有 3 个或 3 个以下字符的词（如果需要，这个数目可以更改）。
- MySQL 带有一个内建的**非用词**（stopword）**列表**，这些词在索引全文本数据时总是被忽略。
> 如果需要，可以覆盖这个列表。
- 许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。
> MySQL 规定了一条 **50% 规则**，如果一个词出现在 50% 以上的行中，则将它作为一个非用词忽略。
> 
> 50% 规则**不用于 IN BOOLEANMODE**。
- 如果表中的行数**少于 3 行**，则全文本搜索**不返回结果**。
> 因为每个词或者不出现，或者至少出现在 50% 的行中。
- **忽略**词中的**单引号**。
> 例如，don't 索引为 dont。
- 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。
- 仅在 **MyISAM 数据库引擎**中支持全文本搜索。

**邻近搜索**是许多全文本搜索支持的一个特性，它能搜索相邻的词。
> 在相同的句子中、相同的段落中或者在特定数目的词的部分中，等等。
> 
> **MySQL** 全文本搜索目前**不支持邻近操作符**。
