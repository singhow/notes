##并行数据处理与性能
###并行流
Stream 接口中可通过对收集源调用 **parallelStream 方法**来把**集合转换为并行流**。
> 并行流就是一个把内容分成多个数据块，并用不同的线程分别处理每个数据块的流。

对顺序流**调用 parallel 方法**并不意味着流本身有任何实际的变化，它只是在内部设了一个 **boolean 标志**，表示在调用 parallel 之后进行的所有操作都并行执行。
> 对并行流调用 **sequential 方法**就可以把它**变成顺序流**。

![](https://i.imgur.com/xFRWJkP.png)

并行流内部使用了默认的 **ForkJoinPool**，它默认的**线程数量**即处理器数量，该值由 **Runtime.getRuntime().availableProcessors()** 得到。

通过系统属性 java.util.concurrent.ForkJoinPool.common.parallelism 可**改变线程池的大小**。
```
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism","12");
```
> **全局设置**，会影响代码中所有的并行流。

**Stream.iterate() 方法**生成的是**装箱的对象**，必须拆箱成数字才能求和。
> 也**很难**把 iterate **分割**成多个独立块来执行，因为需要**依赖前一次的结果**。

![](https://i.imgur.com/s9gXWtv.png)
> LongStream.rangeClosed 直接产生**原始类型的 long** 数字，**没有装箱拆箱的开销**。
> 
> LongStream.rangeClosed 会生成**数字范围**，很**容易拆分**为独立的小块。

选择**适当的数据结构**往往比并行化算法更重要。使用正确的数据结构然后使其并行工作能够保证最佳的性能。
> 并行化过程本身需要**对流做递归划分**，把每个子流的归纳操作**分配到不同的线程**，然后把这些操作的结果**合并成一个值**。
> 
> 在多个内核之间移动数据的代价也可能很大，所以很重要的一点是要**保证在内核中并行执行工作的时间比在内核之间传输数据的时间长**。

在某个特定情况下是否应使用并行流的一些建议：
- 考虑选择顺序流还是并行流时，首先应**使用适当的基准来检查其性能**。
- 应**留意装箱成本**，自动装箱和拆箱操作会大大降低性能。
> 原始类型流（IntStream、LongStream、 DoubleStream）可避免性能成本。
- 有些操作在**并行流上的性能比顺序流差**。
> 特别是 limit 和 findFirst 等**依赖于元素顺序的操作**，它们在并行流上执行的代价非常大。
- 需要考虑**流的操作流水线的总计算成本**。
> 设 N 是要处理的元素的总数，Q 是一个元素通过流水线的大致处理成本，则 N*Q 就是这个对成本的一个粗略的定性估计。
> > Q 值较高就意味着使用并行流时性能好的可能性比较大。
- 对于**较小的数据量**，并**不适合并行流**。
- 需要考虑**流背后的数据结构是否易于分解**。
> ArrayList 的拆分效率比 LinkedList 高得多，因为前者用不着遍历就可以平均拆分，而后者则必须遍历。
> 
> range 方法创建的原始类型流也可以快速分解。
- 流自身的特点，以及流水线中的**中间操作修改流的方式**，都**可能会改变分解过程的性能**。
> 一个 SIZED 流可以分成大小相等的两部分，这样每个部分都可以比较高效地并行处理，但筛选操作可能丢弃的元素个数却无法预测，导致流本身的大小未知。
- 需要考虑终端操作中**合并步骤的代价**是大是小。 

**流的数据源和可分解性**

| 源 | 可分解性 |
| --- | --- |
| ArrayList | 极佳 |
| LinkedList | 差 |
| IntStream.range | 极佳 |
| Stream.iterate | 差 |
| HashSet | 好 |
| TreeSet | 好 |

###分支/合并框架
并行流背后使用的基础架构是**分支/合并框架**，该框架的目的是**以递归方式将可以并行的任务拆分成更小的任务**，然后**将每个子任务的结果合并**起来生成整体结果。
> 它是 **ExecutorService 接口**的一个实现，它把子任务分配给线程池（ForkJoinPool）中的工作线程。

要**将任务提交到线程池**，必须**创建 RecursiveTask&lt;R> 的一个子类**，其中 **R** 是并行化任务（以及所有子任务）产生的**结果类型**。
> 若任务不返回结果，则是 RecursiveAction 类型。

要定义 RecursiveTask， 只需实现它唯一的抽象方法 **compute**：
```
protected abstract R compute();
```
> 该方法同时**定义了将任务拆分成子任务的逻辑**，以及无法再拆分或不方便再拆分时，**生成单个子任务结果的逻辑**。

![](https://i.imgur.com/rw3TTZA.png)
> 这是**分治算法的并行版本**。

![](https://i.imgur.com/pQ3rGNI.png)
> 当把 ForkJoinSumCalculator 任务传给 ForkJoinPool 时，这个任务就**由池中的一个线程执行**，这个线程会**调用任务的 compute 方法**。
> > 该方法会检查任务**是否小到足以顺序执行**，如果不够小则会把要求和的数组分成两半，分给两个新的 ForkJoinSumCalculator，而它们也由 ForkJoinPool 安排执行。
> 
> > 这一过程可以**递归重复**，把原任务**分为更小的任务**，直到满足不能再进一步拆分的条件。
> 
> 这时会**顺序计算每个任务的结果**，然后由分支过程创建的（隐含的）任务二叉树**遍历回到它的根**。接下来会合并每个子任务的部分结果，从而得到总任务的结果。

有效使用分支/合并框架的最佳做法：
- 对一个任务**调用 join 方法会阻塞调用方**，直到该任务做出结果。
> 应该在两个子任务的计算都开始后再调用它。
- 应该始终**直接调用 compute 或 fork 方法**，只有**顺序代码**才应用 **invoke 方法**来启动并行计算。
- 对子任务**调用 fork 方法**可以把它**排进 ForkJoinPool**。
> 应该对其中一个子任务**重用同一线程**，这可避免在线程池中多分配一个任务造成的开销。
- 调用 compute 的线程并不是概念上的调用方，后者是调用 fork 的那个。
- 应把**输入/输出放在一个子任务**里，**计算放在另一个**里，这样计算就可以和输入/输出同时进行。
> 任何其他 Java 代码一样，分支/合并框架**需要“预热”**或者说要执行几遍才**会被 JIT 编译器优化**。
> 
> 这就是为何在测量性能之前运行几次遍程序很重要。

**分出大量的小任务**一般来说都是一个好的选择。因为在理想情况下，划分并行任务时应该**让每个任务都用完全相同的时间完成**，让所有的 CPU 内核都同样繁忙。
> 然而在实际中，每个子任务所花的时间可能天差地别，要么是因为划分策略效率低，要么是有不可预知的原因，比如磁盘访问慢，或是需要和外部服务协调执行。

分支/合并框架工程用一种称为**工作窃取**（work stealing）的技术来解决这个问题。
> 在实际应用中，这些任务差不多被**平均分配到 ForkJoinPool 中的所有线程**上。每个线程都为分配给它的任务保存一个**双向链式队列**，每完成一个任务，就会从队列头上取出下一个任务开始执行。
> 
> 若某个线程很早就完成了分配给它的所有任务，即它的**队列已经为空**，则它会**随机选择一个别的线程**，从队列的尾部上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。
> 
> 划成许多小任务而不是少数几个大任务有助于**更好地在工作线程之间平衡负载**。

一般来说，这种**工作窃取算法**用于在池中的工作线程之间**重新分配和平衡任务**。
![](https://i.imgur.com/04WUiXv.png)
> 当工作线程队列中有一个任务被分成两个子任务时，一个子任务就被闲置的工作线程“偷走”了。
> 
> 这个过程可以不断递归，直到规定子任务应顺序执行的条件为真。

###Spliterator
Spliterator 表示**可分迭代器**（splitable iterator），它用于**遍历数据源中的元素**，但它是为了**并行执行**而设计的。

**Spliterator 接口源码**如下：
```
public interface Spliterator<T> {
	boolean tryAdvance(Consumer<? super T> action);
	Spliterator<T> trySplit();
	long estimateSize();
	int characteristics();
}
```
- **T** 是 Spliterator **遍历的元素类型**。
- **tryAdvance 方法**
> 按序逐个使用 Spliterator 中的元素。
- **trySplit 方法**
> 可把一些元素划出去分给第二个 Spliterator（由该方法返回），让它们两个并行处理。
- **estimateSize 方法**
> 估计还剩下多少元素要遍历。
- **characteristics 方法**
> 声明 Spliterator 的特性。

将 Stream 拆分成多个部分的算法是一个递归过程，
![](https://i.imgur.com/pmWZkyg.png)
> 第一步，对第一个 Spliterator **调用 trySplit**，生成第二个 Spliterator。
> 
> 第二步，对这两个 Spliterator **调用 trysplit**，此时共有四个 Spliterator。
> 
> 第三步，**不断**对 Spliterator **调用 trySplit**，直到它返回 null，表明此时它处理的数据结构不能再分割。
> 
> 第四步，**递归拆分过程终止**，所有的 Spliterator 在调用 trySplit 时都返回 null。

这个拆分过程也**受 Spliterator 本身的特性影响**，其特性是通过 characteristics 方法声明。
> characteristics 方法将返回一个 int，**代表 Spliterator 本身特性集的编码**。

**Spliterator 的特性**如下：
- **ORDERED**
> 元素**有既定的顺序**（例如 List），Spliterator 在遍历和划分时也会遵循这一顺序。
- **DISTINCT**
> 对于任意一对遍历过的元素 x 和 y， x.equals(y) 返回 false。
- **SORTED**
> 遍历的元素按照一个**预定义的顺序排序**。
- **SIZED**
> 该 Spliterator 由一个**已知大小的源建立**（例如 Set），因此 estimatedSize() 返回的是准确值。
- **NONNULL**
> 保证遍历的元素**不会为 null**。
- **IMMUTABLE**
> Spliterator 的**数据源不能修改**。这意味着在遍历时不能添加、删除或修改任何元素。
- **CONCURRENT**
> 该 Spliterator 的数据源可以被其他线程**同时修改而无需同步**。
- **SUBSIZED**
> 该 Spliterator 和所有从它拆分出来的 Spliterator 都是 SIZED。

Spliterator 可以在第一次遍历、第一次拆分或第一次查询估计大小时绑定元素的数据源，而**不是在创建时就绑定**。
> 此时它称为**延迟绑定**（late-binding）的 Spliterator。
