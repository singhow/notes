##默认方法
Java 8 中的接口**支持在声明方法的同时提供实现**，通过两种方式可以完成这种操作：
- 其一，Java 8 允许**在接口内声明静态方法**。
- 其二，通过默认方法**指定接口方法的默认实现**。
> 默认方法让类可以**自动地继承接口的一个默认实现**。
> > 实现接口的类若不显式地提供该方法的具体实现，就会自动继承默认的实现。

![](https://i.imgur.com/rYt81v8.png)

**默认方法**为接口的演进提供了一种平滑的方式，你的**改动将不会导致已有代码的修改**。
> **同时定义接口以及工具辅助类**（companion class）是 Java 语言常用的一种模式，工具类定义了与接口实例协作的很多静态方法。
> > **Collections** 就是**处理 Collection 对象的辅助类**。

###不断演进的 API
变更对 Java 程序的影响大体可以分成**三种类型的兼容性**:
- **二进制级的兼容**
> 现有的二进制执行文件能**无缝持续链接**（包括验证、准备和解析）**和运行**。
> 
> **为接口添加一个方法**就是**二进制级的兼容**。
> > 此时，若新添加的方法不被调用，接口已经实现的方法可以继续运行，不会出现错误。
- **源代码级的兼容**
> 引入变化之后，现有的程序**依然能成功编译通过**。
> 
> 向接口添加新的方法就**不是源码级的兼容**，因为遗留代码并没有实现新引入的方法，所以它们无法顺利通过编译。
- **函数行为的兼容**
> 变更发生之后，程序接受**同样的输入能得到同样的结果**。
> 
> 为接口添加新的方法就**是函数行为兼容**的，因为新添加的方法在程序中并未被调用（抑或该接口在实现中被覆盖了）。

###概述默认方法
Java 8 中的接口包含的方法签名在它的**实现类中也可以不提供实现**，缺失的方法实现会作为接口的一部分由实现类继承（所以命名为默认实现），而无需由实现类提供。
> 默认方法由 **default 修饰符**修饰，并像类中声明的其他方法一样**包含方法体**。

```
public interface Sized {
	int size();

	default boolean isEmpty() {
		return size() == 0;
	}
}
```
> Sized 接口包含两个方法，其中 isEmpty 是默认方法。
> > 任何实现了 Sized 接口的类都会自动继承 isEmpty 的实现。

Java 8 中**抽象类和抽象接口**的区别如下：
- 首先，一个类**只能继承一个抽象类**，但是一个类**可以实现多个接口**。
- 其次，一个抽象类**可以通过实例变量（字段）保存一个通用状态**，而接口是不能有实例变量的。

###默认方法的使用模式
默认方法有两种使用方式：
- **可选方法**
- **行为的多继承**

**可选方法**的用法如下：
```
interface Iterator<T> {
	boolean hasNext();
	T next();
	default void remove() {
		throw new UnsupportedOperationException();
	}
}
```
> 这种方式可以**减少无效的模板代码**，实现 Iterator 接口的类也**无须再声明一个空的 remove 方法**。

**行为的多继承**是一种让类**从多个来源重用代码**的能力，如下图所示：
![](https://i.imgur.com/lefia1r.png)

Java 的类**只能继承单一的类**，但是一个类**可以实现多接口**。
> 由于 Java 8 中接口方法**可以包含实现**，因此类**可以从多个接口中继承它们的行为**（即实现的代码）。
> 
> 保持接口的**精致性和正交性**能帮助你在现有的代码基础上最大程度地**实现代码复用和行为组合**。

继承**不应该成为**在需要代码复用就试图倚靠的方法。
> 比如，从一个拥有很多方法及字段的类进行继承就不是个好主意，因为这其实**会引入不必要的复杂性**。
> > 此时可以**使用代理**有效地规避这种窘境，即**创建一个方法通过该类的成员变量直接调用该类的方法**。
> 
> > 这也是为何有些类被刻意地**声明为 final 类型**的原因，声明为 final 的类**不能被其他的类继承**，避免发生这样的反模式，防止核心代码的功能被污染。

###解决冲突的规则
C++ 中的**菱形继承问题**是指一个类同时继承了**具有相同函数签名的两个方法**。

若一个类**使用相同的函数签名**从多个地方（比如另一个类或接口）继承了方法，通过三条规则可以进行判断：
- **类中的方法优先级最高**。
> 类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。
- 若无法依据第一条进行判断，那么**子接口的优先级更高**。
> 类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。
- 最后，若还是无法判断，那继承了多个接口的类**必须通过显式覆盖和调用期望的方法**显式地选择使用哪一个默认方法的实现。
